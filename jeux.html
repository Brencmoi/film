<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portail de Jeux</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <style>
        :root {
            --background-color: #0c0a18;
            --text-primary: #f0f0f0;
            --primary-accent: #00ffc3;
            --secondary-accent: #ff00c1;
            --card-bg: rgba(0, 255, 195, 0.05);
            --card-border: rgba(0, 255, 195, 0.2);
            --font-pixel: 'Press Start 2P', cursive;
            --font-sans: 'Inter', sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-primary);
            font-family: var(--font-sans);
            overflow-x: hidden;
        }
        
        /* --- Conteneurs principaux --- */
        .game-section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem 1rem;
            animation: fadeIn 0.5s ease-in-out;
        }

        .game-container { display: none; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- Écran de sélection des jeux --- */
        #game-selection-screen h1 {
            font-family: var(--font-pixel);
            color: var(--primary-accent);
            text-shadow: 0 0 10px var(--primary-accent), 0 0 20px var(--secondary-accent);
            font-size: clamp(1.8rem, 8vw, 3rem);
            margin-bottom: 3rem;
        }

        .game-card {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 1rem;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(5px);
            height: 100%;
        }

        .game-card:hover {
            transform: scale(1.05);
            border-color: var(--primary-accent);
            box-shadow: 0 0 20px rgba(0, 255, 195, 0.3);
        }

        .game-card i { font-size: 3rem; color: var(--primary-accent); margin-bottom: 1rem; }
        .game-card h3 { font-family: var(--font-pixel); font-size: 0.8rem; }

        /* --- Boutons de navigation --- */
        .back-button {
            position: fixed; top: 15px; left: 15px; z-index: 10000;
            border-radius: 50%; width: 45px; height: 45px;
            display: flex; align-items: center; justify-content: center;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; transition: all 0.3s ease; text-decoration: none;
        }

        .back-button:hover { background-color: var(--primary-accent); color: var(--background-color); }

        /* --- Style générique des jeux --- */
        .game-title { font-family: var(--font-pixel); color: var(--primary-accent); margin-bottom: 2rem; text-align: center; font-size: 1.5rem; }
        .game-btn { font-family: var(--font-pixel); font-size: 0.7rem; padding: 0.7rem 1.2rem; border-radius: 8px; border: 2px solid var(--primary-accent); background: transparent; color: var(--primary-accent); transition: all 0.3s ease; text-decoration: none; display: inline-block; margin: 0.25rem;}
        .game-btn:hover:not(:disabled) { background: var(--primary-accent); color: var(--background-color); box-shadow: 0 0 15px var(--primary-accent); }
        .game-btn:disabled { border-color: #555; color: #555; cursor: not-allowed; }
        .game-canvas { background-color: #111; border: 2px solid var(--primary-accent); box-shadow: 0 0 15px var(--primary-accent); max-width: 100%; height: auto; }
        .score-container { font-size: 1.2rem; margin-bottom: 1rem; }
        .game-instructions { font-size: 0.8rem; color: #aaa; margin-top: 1rem; }
        
        .coming-soon {
            text-align: center;
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 1rem;
            padding: 3rem;
            backdrop-filter: blur(5px);
        }
        .coming-soon p { font-size: 1.2rem; margin-top: 1.5rem; }

        /* --- Overlay Game Over / Victoire --- */
        #game-over-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            display: none; align-items: center; justify-content: center;
            flex-direction: column; z-index: 10001; animation: fadeIn 0.3s;
        }
        #game-over-box {
            background: #16213e;
            border: 2px solid var(--primary-accent);
            box-shadow: 0 0 20px var(--primary-accent);
            padding: 2rem 3rem; text-align: center; border-radius: 8px;
        }
        #game-over-title {
            font-family: var(--font-pixel);
            font-size: 2rem; color: var(--secondary-accent);
            text-shadow: 0 0 10px var(--secondary-accent);
            margin-bottom: 1.5rem;
        }
        #game-over-score {
            font-size: 1.2rem; margin-bottom: 2rem;
        }

        /* --- Style JOKER POKER (BALATRO) --- */
        #game-jokerpoker-container { background-color: #1a1a2e; position: relative; }
        #game-jokerpoker { max-width: 900px; width:100%; text-align: center; position: relative; z-index: 2;}
        .jokerpoker-ui-grid { display: grid; grid-template-columns: 1fr 2fr 1fr; gap: 1rem; font-family: var(--font-pixel); font-size: 0.7rem; margin-bottom: 1rem; color: #fff; }
        .jokerpoker-info-box { background: #16213e; border: 2px solid #0f3460; padding: 0.5rem; border-radius: 8px; text-align: left; }
        .jokerpoker-info-box h4 { font-size: 0.8rem; color: var(--secondary-accent); margin-bottom: 0.5rem;}
        .jokerpoker-card { width: 80px; height: 110px; border-radius: 8px; background: #fff; color: #000; border: 2px solid #aaa; cursor: pointer; box-shadow: 3px 3px 5px rgba(0,0,0,0.3); transition: all 0.2s ease; position: relative; display: flex; flex-direction: column; justify-content: space-between; padding: 5px; }
        .jokerpoker-card.selected { transform: translateY(-20px); border-color: var(--primary-accent); box-shadow: 0 10px 15px var(--primary-accent);}
        .jokerpoker-card-value { font-size: 1.5rem; font-weight: bold; align-self: flex-start; } .jokerpoker-card-suit { font-size: 1.5rem; align-self: flex-end; } .jokerpoker-card.red { color: #d63031; }
        
        /* --- Style TETRIS --- */
        #game-tetris { display: flex; gap: 2rem; align-items: flex-start; flex-wrap: wrap; justify-content: center; }
        #tetris-sidebar { background: var(--card-bg); border: 2px solid var(--card-border); border-radius: 1rem; padding: 1.5rem; min-width: 180px; }
        #tetris-next { background: #111; border: 2px solid var(--primary-accent); }

        /* --- Style SNAKE --- */
        #game-snake { display: flex; flex-direction: column; align-items: center; gap: 1rem; }

        /* --- Style PONG --- */
        #game-pong { text-align: center; }
        #pong-score { font-family: var(--font-pixel); font-size: 2rem; margin-bottom: 1rem; }
        
        /* --- Style BREAKOUT --- */
        #game-breakout { text-align: center; }
        #breakout-score { font-size: 1.5rem; margin-bottom: 1rem; }

        /* --- Style MORPION (TicTacToe) --- */
        #game-tictactoe { text-align: center; }
        #tictactoe-board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; width: 300px; height: 300px; margin: 1rem auto; }
        .tictactoe-cell {
            width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
            background: #111; border: 2px solid var(--card-border); border-radius: 8px;
            font-size: 3rem; font-family: var(--font-pixel); cursor: pointer; transition: all 0.2s;
        }
        .tictactoe-cell:hover { background-color: var(--card-bg); }
        .tictactoe-cell.X { color: var(--primary-accent); }
        .tictactoe-cell.O { color: var(--secondary-accent); }
        #tictactoe-message { font-size: 1.2rem; margin-top: 1rem; min-height: 1.5rem; }

        /* --- Style FLAPPY BIRD --- */
        #game-flappybird { text-align: center; }
        #flappybird-score { font-size: 1.5rem; margin-bottom: 1rem; }
        
        /* --- Style 2048 --- */
        #game-2048 { text-align: center; }
        #2048-board {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
            width: 340px; height: 340px; padding: 10px;
            background: #2a2a4a; border: 2px solid var(--card-border); border-radius: 8px;
        }
        .tile-2048 {
            width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
            border-radius: 4px; background-color: #3a3a5a;
            font-family: var(--font-pixel); font-size: 1.5rem; color: #fff;
            transition: all 0.1s ease-in-out;
        }
        .tile-2048[data-value="2"] { background-color: #eee4da; color: #776e65; }
        .tile-2048[data-value="4"] { background-color: #ede0c8; color: #776e65; }
        .tile-2048[data-value="8"] { background-color: #f2b179; color: #f9f6f2; }
        .tile-2048[data-value="16"] { background-color: #f59563; color: #f9f6f2; }
        .tile-2048[data-value="32"] { background-color: #f67c5f; color: #f9f6f2; }
        .tile-2048[data-value="64"] { background-color: #f65e3b; color: #f9f6f2; }
        .tile-2048[data-value="128"] { background-color: #edcf72; color: #f9f6f2; font-size: 1.3rem; }
        .tile-2048[data-value="256"] { background-color: #edcc61; color: #f9f6f2; font-size: 1.3rem; }
        .tile-2048[data-value="512"] { background-color: #edc850; color: #f9f6f2; font-size: 1.3rem; }
        .tile-2048[data-value="1024"] { background-color: #edc53f; color: #f9f6f2; font-size: 1rem; }
        .tile-2048[data-value="2048"] { background-color: #edc22e; color: #f9f6f2; font-size: 1rem; }

        /* --- Style PUISSANCE 4 (Connect Four) --- */
        #game-connectfour { text-align: center; }
        #connectfour-board {
            display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px;
            width: 340px; height: 290px; padding: 10px;
            background: #00008B; border: 4px solid #000040; border-radius: 8px;
            margin: auto;
        }
        .connectfour-cell {
            width: 40px; height: 40px; background: #111;
            border-radius: 50%; cursor: pointer;
            border: 2px solid #0c0a18;
            transition: all 0.2s;
        }
        .connectfour-cell.player1 { background-color: #ff4136; }
        .connectfour-cell.player2 { background-color: #ffdc00; }
        .connectfour-col:hover .connectfour-cell:not(.player1):not(.player2) {
            background-color: rgba(255, 65, 54, 0.3);
        }
        #connectfour-message { font-size: 1.2rem; margin-top: 1rem; min-height: 1.5rem; }

        /* --- Style PENDU (Hangman) --- */
        #game-hangman { text-align: center; }
        #hangman-word {
            display: flex; gap: 10px; justify-content: center;
            margin: 2rem 0;
            font-family: var(--font-pixel); font-size: 2rem;
        }
        .hangman-letter {
            width: 40px; height: 50px; line-height: 50px; text-align: center;
            background: #222; border-bottom: 3px solid var(--primary-accent);
            color: var(--text-primary);
        }
        #hangman-keyboard {
            display: flex; flex-wrap: wrap; justify-content: center;
            gap: 8px; max-width: 500px; margin: auto;
        }
        .hangman-key {
            font-family: var(--font-pixel); font-size: 1rem;
            width: 40px; height: 40px; border: 2px solid var(--card-border);
            background: var(--card-bg); color: var(--text-primary);
            cursor: pointer; transition: all 0.2s;
        }
        .hangman-key:hover { background: var(--primary-accent); color: #000; }
        .hangman-key:disabled { background: #333; color: #555; cursor: not-allowed; }
        #hangman-attempts { margin-top: 1rem; font-size: 1.2rem; }

        /* --- Style MEMORY --- */
        #game-memory { text-align: center; }
        #memory-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
            max-width: 400px; margin: auto;
        }
        .memory-card {
            width: 100%; aspect-ratio: 1 / 1;
            background: #1a1a2e; border: 2px solid var(--card-border);
            border-radius: 8px; cursor: pointer;
            transition: transform 0.3s;
            transform-style: preserve-3d;
            display: flex; align-items: center; justify-content: center;
        }
        .memory-card .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden;
            display: flex; align-items: center; justify-content: center;
            border-radius: 6px;
        }
        .memory-card .card-front { background: #1a1a2e; }
        .memory-card .card-back {
            background: var(--card-bg);
            border: 1px solid var(--primary-accent);
            transform: rotateY(180deg);
            font-size: 2.5rem; color: var(--primary-accent);
        }
        .memory-card.is-flipped { transform: rotateY(180deg); }
        .memory-card.is-matched {
            background: var(--card-bg); border-color: var(--primary-accent);
            cursor: default;
        }
        .memory-card.is-matched .card-back {
            background: transparent; border: none;
            opacity: 0.5;
        }
        #memory-moves { margin-top: 1rem; font-size: 1.2rem; }

        /* --- Style DÉMINEUR (Minesweeper) --- */
        #game-minesweeper { text-align: center; }
        #minesweeper-info { font-size: 1.2rem; margin-bottom: 1rem; }
        #minesweeper-board {
            display: grid;
            gap: 2px;
            background: #000;
            border: 2px solid var(--card-border);
            margin: auto;
            /* Sera défini par JS */
        }
        .minesweeper-cell {
            width: 30px; height: 30px;
            background: #111;
            border: 1px solid #333;
            display: flex; align-items: center; justify-content: center;
            font-family: var(--font-pixel); font-size: 1rem;
            color: #fff; cursor: pointer;
            user-select: none;
        }
        .minesweeper-cell.revealed {
            background: #2a2a4a;
            border-color: #444;
        }
        .minesweeper-cell.flagged { color: var(--secondary-accent); }
        .minesweeper-cell.mine { background: #ff4136; }
        /* Couleurs pour les numéros */
        .minesweeper-cell[data-count="1"] { color: #0DC2FF; }
        .minesweeper-cell[data-count="2"] { color: #0DFF72; }
        .minesweeper-cell[data-count="3"] { color: #F538FF; }
        .minesweeper-cell[data-count="4"] { color: #FFE138; }
        .minesweeper-cell[data-count="5"] { color: #FF8E0D; }
        .minesweeper-cell[data-count="6"] { color: #FF0D72; }
        
        /* --- Style BLACKJACK --- */
        #game-blackjack { text-align: center; }
        .blackjack-hand {
            display: flex; justify-content: center; gap: 10px;
            min-height: 120px; margin: 1rem 0;
        }
        .blackjack-card {
            width: 80px; height: 110px; border-radius: 8px;
            background: #fff; color: #000; border: 2px solid #aaa;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; justify-content: space-between; padding: 5px;
        }
        .blackjack-card-hidden {
            background: repeating-linear-gradient(45deg, #555, #555 10px, #444 10px, #444 20px);
            border-color: #333;
        }
        .blackjack-card-value { font-size: 1.5rem; font-weight: bold; align-self: flex-start; }
        .blackjack-card-suit { font-size: 1.5rem; align-self: flex-end; }
        .blackjack-card.red { color: #d63031; }
        
        #blackjack-message { font-size: 1.2rem; margin-top: 1rem; min-height: 1.5rem; font-weight: bold; }
        #blackjack-scores { font-family: var(--font-pixel); font-size: 1.2rem; }
        
    </style>
</head>
<body>

    <a href="index.html" class="back-button" title="Retour au blog"><i class="bi bi-house-door-fill"></i></a>
    <button id="back-to-menu-btn" class="back-button" title="Retour au menu" style="display: none; left: 75px;"><i class="bi bi-list"></i></button>

    <div id="game-selection-screen" class="game-section">
        <div class="container text-center">
            <h1>ARCADE</h1>
            <div class="row g-4 g-md-5 justify-content: center">
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="jokerpoker"><i class="bi bi-suit-club-fill"></i><h3>Joker Poker</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="tetris"><i class="bi bi-bricks"></i><h3>Tetris</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="snake"><i class="bi bi-bug-fill"></i><h3>Snake</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="pong"><i class="bi bi-arrows-expand-vertical"></i><h3>Pong</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="breakout"><i class="bi bi-distribute-vertical"></i><h3>Breakout</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="tictactoe"><i class="bi bi-hash"></i><h3>Morpion</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="flappybird"><i class="bi bi-cloud-fill"></i><h3>Flappy Bird</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="2048"><i class="bi bi-grid-1x2-fill"></i><h3>2048</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="connectfour"><i class="bi bi-grid-3x3-gap-fill"></i><h3>Puissance 4</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="hangman"><i class="bi bi-emoji-dizzy-fill"></i><h3>Pendu</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="memory"><i class="bi bi-question-diamond-fill"></i><h3>Memory</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="minesweeper"><i class="bi bi-flag-fill"></i><h3>Démineur</h3></div></div>
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="blackjack"><i class="bi bi-suit-spade-fill"></i><h3>Blackjack</h3></div></div>
                
                <div class="col-4 col-md-3 col-lg-2"><div class="game-card" data-game="pacman"><i class="bi bi-joystick"></i><h3>Pac-Man</h3></div></div>
            </div>
        </div>
    </div>
    
    <div id="game-over-overlay">
        <div id="game-over-box">
            <h2 id="game-over-title">GAME OVER</h2>
            <p id="game-over-score">Score: 0</p>
            <button id="game-over-restart" class="game-btn">Rejouer</button>
            <button id="game-over-menu" class="game-btn">Menu</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- MOTEUR DE NAVIGATION PRINCIPAL ---
        const gameSelectionScreen = document.getElementById('game-selection-screen');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const gameCards = document.querySelectorAll('.game-card');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverScore = document.getElementById('game-over-score');
        const gameOverRestart = document.getElementById('game-over-restart');
        const gameOverMenu = document.getElementById('game-over-menu');
        
        let activeGameLoop = null;
        let activeKeyListener = null;
        let activeMouseListener = null;

        gameCards.forEach(card => card.addEventListener('click', () => showGame(card.dataset.game)));
        backToMenuBtn.addEventListener('click', showMenu);
        gameOverMenu.addEventListener('click', showMenu);
        
        // Création dynamique des conteneurs de jeux
        const allGameIds = Array.from(gameCards).map(gc => gc.dataset.game);
        allGameIds.forEach(id => {
            if (!document.getElementById(`game-${id}-container`)) {
                const container = document.createElement('div');
                container.id = `game-${id}-container`;
                container.className = 'game-container game-section';
                document.body.appendChild(container);
            }
        });
        const gameContainers = document.querySelectorAll('.game-container');

        function cleanUp() {
            if (activeGameLoop) {
                if (typeof activeGameLoop === 'number') cancelAnimationFrame(activeGameLoop);
                else clearInterval(activeGameLoop);
                activeGameLoop = null;
            }
            if(activeKeyListener) {
                document.removeEventListener('keydown', activeKeyListener);
                document.removeEventListener('keyup', activeKeyListener); 
                activeKeyListener = null;
            }
            if(activeMouseListener) {
                // Pour Flappy Bird, Démineur, etc.
                document.removeEventListener('click', activeMouseListener);
                document.removeEventListener('contextmenu', activeMouseListener); // Pour Démineur
                activeMouseListener = null;
            }
            hideGameOver();
        }

        function showGame(gameId) {
            cleanUp(); 
            gameSelectionScreen.style.display = 'none';
            backToMenuBtn.style.display = 'flex';
            gameContainers.forEach(container => container.style.display = 'none');
            
            const activeContainer = document.getElementById(`game-${gameId}-container`);
            if (activeContainer) {
                activeContainer.style.display = 'flex';
                const initFunctionName = `init${gameId.charAt(0).toUpperCase() + gameId.slice(1)}`;
                if (window[initFunctionName]) {
                    window[initFunctionName](); 
                } else {
                    console.error(`Fonction d'initialisation ${initFunctionName} non trouvée.`);
                }
            }
        }

        function showMenu() {
            cleanUp(); 
            gameSelectionScreen.style.display = 'flex';
            backToMenuBtn.style.display = 'none';
            gameContainers.forEach(container => container.style.display = 'none');
        }

        // --- Système d'Overlay Game Over ---
        function showGameOver(title, scoreText, restartCallback) {
            gameOverTitle.textContent = title;
            gameOverScore.textContent = scoreText;
            gameOverRestart.onclick = () => {
                hideGameOver();
                restartCallback(); 
            };
            gameOverOverlay.style.display = 'flex';
        }

        function hideGameOver() {
            gameOverOverlay.style.display = 'none';
        }

        /*
        ====================================================================
        LES 11 JEUX PRÉCÉDENTS SONT ICI (MINIMISÉS POUR LA LISIBILITÉ)
        Joker Poker, Tetris, Snake, Pong, Breakout, Morpion,
        Flappy Bird, 2048, Puissance 4, Pendu, Memory
        ====================================================================
        */

        // --- MOTEUR DE JEU : JOKER POKER (BALATRO) ---
        const jokerPoker = {
            dom: {}, deck: [], hand: [], selectedCards: [],
            ranks: "2,3,4,5,6,7,8,9,T,J,Q,K,A".split(","),
            suits: "♥,♦,♣,♠".split(","),
            cardChips: { 'A': 11, 'K': 10, 'Q': 10, 'J': 10, 'T': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2 },
            handLevels: { "Haute Carte": { chips: 5, multi: 1 }, "Paire": { chips: 10, multi: 2 }, "Double Paire": { chips: 20, multi: 3 }, "Brelan": { chips: 30, multi: 4 }, "Suite": { chips: 40, multi: 5 }, "Couleur": { chips: 50, multi: 6 }, "Full": { chips: 60, multi: 7 }, "Carré": { chips: 80, multi: 8 }, "Quinte Flush": { chips: 100, multi: 10 }, },
            blinds: [ { name: "Petit Blind", score: 300, reward: 3 }, { name: "Gros Blind", score: 800, reward: 4 }, { name: "Le Mur", score: 2000, reward: 5 }, ],
            jokerDatabase: [ { name: "Joker Fou", desc: "+4 Multi", cost: 3, effect: (calc) => { calc.totalMulti += 4; } }, { name: "Le Glouton", desc: "+40 Jetons", cost: 3, effect: (calc) => { calc.totalChips += 40; } }, { name: "As de Pique", desc: "Les Piques donnent +30 Jetons", cost: 4, effect: (calc, hand) => { hand.forEach(c => { if(c.suit === '♠') calc.totalChips += 30; }); }}, { name: "Roi de Coeur", desc: "x2 Multi si main contient un Roi", cost: 4, effect: (calc, hand) => { if(hand.some(c=>c.rank === 'K')) calc.totalMulti *= 2; }} ],
            state: {},
            init: function() {
                this.dom.container = document.getElementById('game-jokerpoker-container');
                if (!this.dom.container) return; 
                this.dom.container.innerHTML = `
                    <div id="game-jokerpoker">
                        <div class="jokerpoker-ui-grid">
                            <div class="jokerpoker-info-box"> <h4>Objectif</h4> <p>Blind: <span id="jokerpoker-blind-name"></span></p> <p>Score Requis: <span id="jokerpoker-target-score"></span></p> </div>
                            <div class="jokerpoker-info-box" style="text-align: center;"> <h4>Jeu</h4> <p>Mains: <span id="jokerpoker-hands-left"></span> | Défausses: <span id="jokerpoker-discards-left"></span></p> <p>Argent: $<span id="jokerpoker-money"></span></p> </div>
                            <div class="jokerpoker-info-box"> <h4>Score Actuel</h4> <p><span id="jokerpoker-current-score"></span></p> </div>
                            <div id="jokerpoker-jokers-area"></div>
                        </div>
                        <div id="jokerpoker-hand"></div>
                        <div id="jokerpoker-play-area">
                            <div id="jokerpoker-hand-info"></div>
                            <button id="jokerpoker-play-btn" class="game-btn mx-2">Jouer</button>
                            <button id="jokerpoker-discard-btn" class="game-btn mx-2">Défausser</button>
                        </div>
                        <div id="jokerpoker-message-area" class="mt-3 fs-5" style="font-family: var(--font-pixel); color: var(--secondary-accent);"></div>
                    </div>
                    <div id="jokerpoker-shop-overlay">
                        <div>
                            <h2 class="game-title">MAGASIN</h2>
                            <div id="jokerpoker-shop-items"></div>
                            <button id="jokerpoker-continue-btn" class="game-btn mt-3">Continuer</button>
                        </div>
                    </div>`;
                const ids = ['targetScoreEl', 'currentScoreEl', 'handsLeftEl', 'discardsLeftEl', 'moneyEl', 'blindNameEl', 'jokersAreaEl', 'handEl', 'handInfoEl', 'messageAreaEl', 'playBtn', 'discardBtn', 'shopOverlay', 'shopItemsEl', 'continueBtn'];
                const domNames = ['jokerpoker-target-score', 'jokerpoker-current-score', 'jokerpoker-hands-left', 'jokerpoker-discards-left', 'jokerpoker-money', 'jokerpoker-blind-name', 'jokerpoker-jokers-area', 'jokerpoker-hand', 'jokerpoker-hand-info', 'jokerpoker-message-area', 'jokerpoker-play-btn', 'jokerpoker-discard-btn', 'jokerpoker-shop-overlay', 'jokerpoker-shop-items', 'jokerpoker-continue-btn'];
                ids.forEach((el, i) => this.dom[el] = document.getElementById(domNames[i]));
                this.dom.playBtn.addEventListener('click', () => this.playHand());
                this.dom.discardBtn.addEventListener('click', () => this.discardHand());
                this.dom.continueBtn.addEventListener('click', () => this.startNextBlind());
                activeGameLoop = null; activeKeyListener = null;
                this.startNewGame();
            },
            startNewGame: function() { this.state = { money: 0, currentBlindIndex: 0, jokers: [] }; this.startBlind(); },
            startBlind: function() {
                const blind = this.blinds[this.state.currentBlindIndex];
                this.state = { ...this.state, handsLeft: 4, discardsLeft: 3, currentScore: 0, targetScore: blind.score };
                this.dom.shopOverlay.style.display = 'none'; this.dom.messageAreaEl.textContent = '';
                this.hand = []; this.selectedCards = [];
                this.createDeck(); this.drawHand(8);
                this.updateUI(); this.toggleButtons(true);
            },
            createDeck: function() {
                this.deck = this.suits.flatMap(suit => this.ranks.map(rank => ({ rank, suit, value: this.ranks.indexOf(rank) + 2 })));
                this.deck.sort(() => Math.random() - 0.5);
            },
            drawHand: function(num) {
                for (let i = 0; i < num; i++) {
                    if (this.hand.length >= 8) break;
                    if (this.deck.length === 0) this.createDeck();
                    this.hand.push(this.deck.pop());
                } this.renderHand();
            },
            renderHand: function() {
                this.dom.handEl.innerHTML = '';
                this.hand.forEach((card) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `jokerpoker-card ${card.suit === '♥' || card.suit === '♦' ? 'red' : ''}`;
                    cardEl.innerHTML = `<span class="jokerpoker-card-value">${card.rank}</span><span class="jokerpoker-card-suit">${card.suit}</span>`;
                    cardEl.addEventListener('click', () => this.selectCard(cardEl, card));
                    this.dom.handEl.appendChild(cardEl);
                });
            },
            selectCard: function(cardEl, card) {
                const cardIndex = this.selectedCards.indexOf(card);
                if (cardIndex > -1) { this.selectedCards.splice(cardIndex, 1); cardEl.classList.remove('selected'); } 
                else if (this.selectedCards.length < 5) { this.selectedCards.push(card); cardEl.classList.add('selected'); }
                this.updateHandInfo();
            },
            calculateScore: function(hand) {
                if (hand.length === 0) return null;
                hand.sort((a,b) => a.value - b.value);
                const ranks = hand.map(c => c.value); const suits = hand.map(c => c.suit);
                const rankCounts = ranks.reduce((acc, v) => { acc[v] = (acc[v] || 0) + 1; return acc; }, {});
                const isFlush = new Set(suits).size === 1;
                const isStraight = ranks.every((v, i, a) => i === 0 || v === a[i-1] + 1) || JSON.stringify(ranks) === JSON.stringify([2,3,4,5,14]);
                const counts = Object.values(rankCounts);
                let handName = "Haute Carte";
                if (isStraight && isFlush) handName = "Quinte Flush"; else if (counts.includes(4)) handName = "Carré";
                else if (counts.includes(3) && counts.includes(2)) handName = "Full"; else if (isFlush) handName = "Couleur";
                else if (isStraight) handName = "Suite"; else if (counts.includes(3)) handName = "Brelan";
                else if (counts.filter(c => c === 2).length === 2) handName = "Double Paire"; else if (counts.includes(2)) handName = "Paire";
                const levelInfo = this.handLevels[handName];
                let calculation = { totalChips: hand.reduce((sum, card) => sum + this.cardChips[card.rank], 0) + levelInfo.chips, totalMulti: levelInfo.multi, };
                this.state.jokers.forEach(joker => joker.effect(calculation, hand));
                const finalScore = calculation.totalChips * calculation.totalMulti;
                return { name: handName, chips: calculation.totalChips, multi: calculation.totalMulti, score: finalScore };
            },
            updateHandInfo: function() {
                const result = this.calculateScore(this.selectedCards);
                if (result) {
                    this.dom.handInfoEl.innerHTML = `<div id="jokerpoker-hand-name">${result.name}</div><div id="jokerpoker-hand-score">${result.chips} x ${result.multi} = ${result.score}</div>`;
                } else { this.dom.handInfoEl.innerHTML = ''; }
            },
            playHand: function() {
                if (this.selectedCards.length === 0) return;
                const result = this.calculateScore(this.selectedCards);
                if (result) {
                    this.state.currentScore += result.score; this.state.handsLeft--;
                    this.hand = this.hand.filter(c => !this.selectedCards.includes(c));
                    this.drawHand(this.selectedCards.length); this.selectedCards = [];
                    this.updateUI(); this.checkGameState();
                }
            },
            discardHand: function() {
                if (this.selectedCards.length === 0 || this.state.discardsLeft <= 0) return;
                this.state.discardsLeft--;
                this.hand = this.hand.filter(c => !this.selectedCards.includes(c));
                this.drawHand(this.selectedCards.length); this.selectedCards = [];
                this.updateUI();
            },
            checkGameState: function() {
                if (this.state.currentScore >= this.state.targetScore) {
                    this.dom.messageAreaEl.textContent = "BLIND BATTU !";
                    this.state.money += this.blinds[this.state.currentBlindIndex].reward;
                    this.toggleButtons(false); setTimeout(() => this.showShop(), 1500);
                } else if (this.state.handsLeft <= 0) {
                    this.toggleButtons(false);
                    showGameOver("GAME OVER", `Score final: ${this.state.currentScore} / ${this.state.targetScore}`, () => this.startNewGame());
                }
            },
            showShop: function() {
                this.dom.messageAreaEl.textContent = "";
                this.dom.shopItemsEl.innerHTML = '';
                const availableJokers = [...this.jokerDatabase].sort(() => .5 - Math.random()).slice(0, 2);
                availableJokers.forEach(joker => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'jokerpoker-shop-item';
                    itemEl.innerHTML = `<div class="jokerpoker-joker"><h5>${joker.name}</h5><p>${joker.desc}</p></div><p class="mt-2">$${joker.cost}</p>`;
                    if (this.state.money < joker.cost) itemEl.style.opacity = '0.5';
                    else itemEl.onclick = () => this.buyJoker(joker);
                    this.dom.shopItemsEl.appendChild(itemEl);
                });
                this.dom.shopOverlay.style.display = 'flex';
            },
            buyJoker: function(joker) {
                if (this.state.money >= joker.cost && this.state.jokers.length < 5) {
                    this.state.money -= joker.cost; this.state.jokers.push(joker);
                    this.updateUI(); this.showShop();
                }
            },
            startNextBlind: function() {
                this.state.currentBlindIndex++;
                if (this.state.currentBlindIndex >= this.blinds.length) {
                    this.toggleButtons(false);
                    showGameOver("VICTOIRE !", "Vous avez battu tous les blinds !", () => this.startNewGame());
                } else { this.startBlind(); }
            },
            updateUI: function() {
                const blind = this.blinds[this.state.currentBlindIndex];
                this.dom.targetScoreEl.textContent = blind.score; this.dom.blindNameEl.textContent = blind.name;
                this.dom.currentScoreEl.textContent = this.state.currentScore;
                this.dom.handsLeftEl.textContent = this.state.handsLeft;
                this.dom.discardsLeftEl.textContent = this.state.discardsLeft;
                this.dom.moneyEl.textContent = this.state.money;
                this.dom.discardBtn.disabled = this.state.discardsLeft <= 0;
                this.dom.jokersAreaEl.innerHTML = '';
                this.state.jokers.forEach(j => { this.dom.jokersAreaEl.innerHTML += `<div class="jokerpoker-joker"><h5>${j.name}</h5><p>${j.desc}</p></div>`; });
                if (this.state.jokers.length === 0) this.dom.jokersAreaEl.innerHTML = '<p style="font-size:0.7rem; color: #888;">Pas de Jokers</p>';
                this.updateHandInfo();
            },
            toggleButtons: function(enabled) { this.dom.playBtn.disabled = !enabled; this.dom.discardBtn.disabled = !enabled || this.state.discardsLeft <= 0; }
        };
        window.initJokerpoker = () => jokerPoker.init();

        // --- MOTEUR DE JEU : TETRIS ---
        window.initTetris = () => {
            const container = document.getElementById('game-tetris-container');
            container.innerHTML = `
                <div id="game-tetris">
                    <canvas id="tetris-board" width="200" height="400" class="game-canvas"></canvas>
                    <div id="tetris-sidebar">
                        <h4 style="font-family: var(--font-pixel); font-size: 0.8rem;">Suivant:</h4>
                        <canvas id="tetris-next" width="80" height="80"></canvas>
                        <div class="score-container mt-3">Score: <span id="tetris-score">0</span></div>
                        <div class="score-container">Lignes: <span id="tetris-lines">0</span></div>
                        <p class="game-instructions">Flèches: bouger<br>Haut: tourner<br>Espace: tomber</p>
                    </div>
                </div>`;
            const canvas = document.getElementById('tetris-board'); const context = canvas.getContext('2d');
            const nextCanvas = document.getElementById('tetris-next'); const nextContext = nextCanvas.getContext('2d');
            const scoreEl = document.getElementById('tetris-score'); const linesEl = document.getElementById('tetris-lines');
            const COLS = 10, ROWS = 20, BLOCK_SIZE = 20;
            const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
            const PIECES = [ [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], [[2,0,0], [2,2,2], [0,0,0]], [[0,0,3], [3,3,3], [0,0,0]], [[4,4], [4,4]], [[0,5,5], [5,5,0], [0,0,0]], [[0,6,0], [6,6,6], [0,0,0]], [[7,7,0], [0,7,7], [0,0,0]] ];
            let board, score, lines, dropStart, piece, nextPiece;
            function initGame() {
                board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
                score = 0; lines = 0; dropStart = Date.now();
                nextPiece = { matrix: PIECES[Math.floor(Math.random() * PIECES.length)] };
                resetPiece(); updateScoreUI();
                if (activeGameLoop) cancelAnimationFrame(activeGameLoop);
                gameLoop();
            }
            function updateScoreUI() { scoreEl.textContent = score; linesEl.textContent = lines; }
            function drawBlock(ctx, x, y, color) { ctx.fillStyle = color; ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); ctx.strokeStyle = '#000'; ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); }
            function draw() {
                context.clearRect(0, 0, canvas.width, canvas.height);
                board.forEach((row, y) => row.forEach((value, x) => { if (value > 0) drawBlock(context, x, y, COLORS[value]); }));
                piece.matrix.forEach((row, y) => row.forEach((value, x) => { if (value > 0) drawBlock(context, piece.x + x, piece.y + y, COLORS[value]); }));
                nextContext.clearRect(0,0, nextCanvas.width, nextCanvas.height);
                nextPiece.matrix.forEach((row, y) => row.forEach((value, x) => { if (value > 0) { const drawX = x + (4 - nextPiece.matrix[0].length) / 2; const drawY = y + (4 - nextPiece.matrix.length) / 2; drawBlock(nextContext, drawX, drawY, COLORS[value]); } }));
            }
            function drop() { if (!collision(0, 1, piece)) { piece.y++; } else { merge(); clearLines(); resetPiece(); } dropStart = Date.now(); }
            function gameLoop() { if (Date.now() - dropStart > 1000) drop(); draw(); activeGameLoop = requestAnimationFrame(gameLoop); }
            function resetPiece() {
                piece = nextPiece; piece.x = Math.floor(COLS / 2) - Math.floor(piece.matrix[0].length / 2); piece.y = 0;
                nextPiece = { matrix: PIECES[Math.floor(Math.random() * PIECES.length)] };
                if (collision(0, 0, piece)) { if(activeGameLoop) cancelAnimationFrame(activeGameLoop); activeGameLoop = null; showGameOver("GAME OVER", `Score: ${score} | Lignes: ${lines}`, initGame); }
            }
            function collision(dx, dy, currentPiece) {
                for (let y = 0; y < currentPiece.matrix.length; y++) {
                    for (let x = 0; x < currentPiece.matrix[y].length; x++) {
                        if (currentPiece.matrix[y][x] !== 0) {
                            let newX = currentPiece.x + x + dx; let newY = currentPiece.y + y + dy;
                            if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX] !== 0)) { return true; }
                        }
                    }
                } return false;
            }
            function merge() { piece.matrix.forEach((row, y) => row.forEach((value, x) => { if (value !== 0) { board[piece.y + y][piece.x + x] = value; } })); }
            function rotate(matrix) { const N = matrix.length - 1; const result = matrix.map((row, i) => row.map((val, j) => matrix[N - j][i])); return result; }
            function pieceRotate() {
                const rotated = rotate(piece.matrix); let offsetX = 1;
                if (!collision(0, 0, { ...piece, matrix: rotated })) { piece.matrix = rotated; } 
                else if (!collision(offsetX, 0, { ...piece, matrix: rotated })) { piece.x += offsetX; piece.matrix = rotated; } 
                else if (!collision(-offsetX, 0, { ...piece, matrix: rotated })) { piece.x -= offsetX; piece.matrix = rotated; }
            }
            function clearLines() {
                let clearedLines = 0;
                outer: for (let y = ROWS - 1; y >= 0; y--) {
                    for (let x = 0; x < COLS; x++) { if (board[y][x] === 0) { continue outer; } }
                    const row = board.splice(y, 1)[0].fill(0); board.unshift(row);
                    clearedLines++; y++; 
                }
                if (clearedLines > 0) { lines += clearedLines; score += clearedLines * 100 * clearedLines; }
                updateScoreUI();
            }
            activeKeyListener = (e) => {
                e.preventDefault();
                if (e.key === 'ArrowLeft') { if (!collision(-1, 0, piece)) piece.x--; }
                else if (e.key === 'ArrowRight') { if (!collision(1, 0, piece)) piece.x++; }
                else if (e.key === 'ArrowDown') drop();
                else if (e.key === 'ArrowUp') pieceRotate();
                else if (e.key === ' ') { while(!collision(0, 1, piece)) piece.y++; drop(); }
                draw();
            };
            document.addEventListener('keydown', activeKeyListener);
            initGame();
        }
        
        // --- MOTEUR DE JEU : SNAKE ---
        window.initSnake = () => {
            const container = document.getElementById('game-snake-container');
            container.innerHTML = `
                <div id="game-snake">
                    <h2 class="game-title">SNAKE</h2>
                    <div class="score-container">Score: <span id="snake-score">0</span></div>
                    <canvas id="snake-board" width="400" height="400" class="game-canvas"></canvas>
                    <p class="game-instructions">Utilisez les flèches pour vous diriger.</p>
                </div>`;
            const canvas = document.getElementById('snake-board'); const context = canvas.getContext('2d');
            const scoreEl = document.getElementById('snake-score');
            const GRID_SIZE = 20; const TILE_COUNT = canvas.width / GRID_SIZE;
            let snake, apple, velocity, score, gameSpeed;
            function initGame() {
                snake = [{ x: 10, y: 10 }]; apple = { x: 15, y: 15 }; velocity = { x: 0, y: 0 };
                score = 0; gameSpeed = 100; scoreEl.textContent = score;
                if (activeGameLoop) clearInterval(activeGameLoop);
                activeGameLoop = setInterval(gameLoop, gameSpeed);
            }
            function gameLoop() {
                const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };
                if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) { return gameOver(); }
                for(let i = 1; i < snake.length; i++) { if (head.x === snake[i].x && head.y === snake[i].y) { return gameOver(); } }
                snake.unshift(head);
                if (head.x === apple.x && head.y === apple.y) {
                    score++; scoreEl.textContent = score; placeApple();
                    clearInterval(activeGameLoop); gameSpeed = Math.max(50, gameSpeed * 0.95);
                    activeGameLoop = setInterval(gameLoop, gameSpeed);
                } else { snake.pop(); }
                draw();
            }
            function placeApple() {
                apple.x = Math.floor(Math.random() * TILE_COUNT); apple.y = Math.floor(Math.random() * TILE_COUNT);
                for(let part of snake) { if (part.x === apple.x && part.y === apple.y) { return placeApple(); } }
            }
            function draw() {
                context.fillStyle = '#111'; context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'var(--primary-accent)';
                snake.forEach(part => { context.fillRect(part.x * GRID_SIZE, part.y * GRID_SIZE, GRID_SIZE - 2, GRID_SIZE - 2); });
                context.fillStyle = 'var(--secondary-accent)';
                context.fillRect(apple.x * GRID_SIZE, apple.y * GRID_SIZE, GRID_SIZE - 2, GRID_SIZE - 2);
            }
            function gameOver() { clearInterval(activeGameLoop); activeGameLoop = null; showGameOver("GAME OVER", `Score: ${score}`, initGame); }
            activeKeyListener = (e) => {
                e.preventDefault();
                switch(e.key) {
                    case 'ArrowUp': if(velocity.y === 0) velocity = { x: 0, y: -1 }; break;
                    case 'ArrowDown': if(velocity.y === 0) velocity = { x: 0, y: 1 }; break;
                    case 'ArrowLeft': if(velocity.x === 0) velocity = { x: -1, y: 0 }; break;
                    case 'ArrowRight': if(velocity.x === 0) velocity = { x: 1, y: 0 }; break;
                }
            };
            document.addEventListener('keydown', activeKeyListener);
            initGame();
        }

        // --- MOTEUR DE JEU : PONG ---
        window.initPong = () => {
            const container = document.getElementById('game-pong-container');
            container.innerHTML = `
                <div id="game-pong">
                    <h2 class="game-title">PONG</h2>
                    <div id="pong-score" class="score-container">0 - 0</div>
                    <canvas id="pong-board" width="600" height="400" class="game-canvas"></canvas>
                    <p class="game-instructions">Haut/Bas pour le joueur de gauche. (Joueur droit = IA)</p>
                </div>`;
            const canvas = document.getElementById('pong-board'); const context = canvas.getContext('2d');
            const scoreEl = document.getElementById('pong-score');
            const PADDLE_HEIGHT = 100, PADDLE_WIDTH = 10; const WINNING_SCORE = 5;
            let ball, player1, player2, keys = {};
            function initGame() {
                ball = { x: canvas.width / 2, y: canvas.height / 2, radius: 10, speed: 5, dx: 5, dy: 5 };
                player1 = { x: 10, y: (canvas.height - PADDLE_HEIGHT) / 2, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, score: 0, speed: 8 };
                player2 = { x: canvas.width - 20, y: (canvas.height - PADDLE_HEIGHT) / 2, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, score: 0, speed: 4 };
                updateScore();
                if (activeGameLoop) cancelAnimationFrame(activeGameLoop);
                gameLoop();
            }
            function updateScore() { scoreEl.textContent = `${player1.score} - ${player2.score}`; }
            function resetBall() { ball.x = canvas.width / 2; ball.y = canvas.height / 2; ball.dx = -ball.dx; ball.speed = 5; }
            function drawRect(x, y, w, h, color) { context.fillStyle = color; context.fillRect(x, y, w, h); }
            function drawCircle(x, y, r, color) { context.fillStyle = color; context.beginPath(); context.arc(x, y, r, 0, Math.PI * 2, false); context.closePath(); context.fill(); }
            function gameLoop() {
                if (keys['ArrowUp'] && player1.y > 0) player1.y -= player1.speed;
                if (keys['ArrowDown'] && player1.y < canvas.height - player1.height) player1.y += player1.speed;
                let aiTarget = ball.y - (player2.height / 2);
                if (player2.y < aiTarget && player2.y < canvas.height - player2.height) player2.y += player2.speed;
                if (player2.y > aiTarget && player2.y > 0) player2.y -= player2.speed;
                ball.x += ball.dx; ball.y += ball.dy;
                if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) ball.dy = -ball.dy;
                if (ball.x - ball.radius < player1.x + player1.width && ball.y > player1.y && ball.y < player1.y + player1.height) { ball.dx = -ball.dx; ball.speed *= 1.1; ball.dx = ball.speed; }
                if (ball.x + ball.radius > player2.x && ball.y > player2.y && ball.y < player2.y + player2.height) { ball.dx = -ball.dx; ball.speed *= 1.1; ball.dx = -ball.speed; }
                if (ball.x - ball.radius < 0) { player2.score++; updateScore(); resetBall(); } 
                else if (ball.x + ball.radius > canvas.width) { player1.score++; updateScore(); resetBall(); }
                drawRect(0, 0, canvas.width, canvas.height, '#111');
                drawRect(player1.x, player1.y, player1.width, player1.height, 'var(--primary-accent)');
                drawRect(player2.x, player2.y, player2.width, player2.height, 'var(--secondary-accent)');
                drawCircle(ball.x, ball.y, ball.radius, 'var(--text-primary)');
                if (player1.score >= WINNING_SCORE) { showGameOver("VICTOIRE !", `Vous avez gagné ${player1.score} à ${player2.score}`, initGame); return; }
                if (player2.score >= WINNING_SCORE) { showGameOver("GAME OVER", `L'IA a gagné ${player2.score} à ${player1.score}`, initGame); return; }
                activeGameLoop = requestAnimationFrame(gameLoop);
            }
            activeKeyListener = (e) => { e.preventDefault(); keys[e.key] = (e.type === 'keydown'); };
            document.addEventListener('keydown', activeKeyListener);
            document.addEventListener('keyup', activeKeyListener);
            initGame();
        }

        // --- MOTEUR DE JEU : BREAKOUT ---
        window.initBreakout = () => {
            const container = document.getElementById('game-breakout-container');
            container.innerHTML = `
                <div id="game-breakout">
                    <h2 class="game-title">BREAKOUT</h2>
                    <div id="breakout-score" class="score-container">Score: 0</div>
                    <canvas id="breakout-board" width="480" height="320" class="game-canvas"></canvas>
                    <p class="game-instructions">Gauche/Droite pour bouger.</p>
                </div>`;
            const canvas = document.getElementById('breakout-board'); const context = canvas.getContext('2d');
            const scoreEl = document.getElementById('breakout-score');
            let ball, paddle, bricks, score, keys = {};
            let brickRowCount = 5, brickColumnCount = 8;
            let brickWidth = 50, brickHeight = 20, brickPadding = 10, brickOffsetTop = 30, brickOffsetLeft = 30;
            function initGame() {
                score = 0; scoreEl.textContent = `Score: 0`;
                ball = { x: canvas.width / 2, y: canvas.height - 30, radius: 10, dx: 4, dy: -4 };
                paddle = { x: (canvas.width - 100) / 2, y: canvas.height - 20, width: 100, height: 10, speed: 7 };
                bricks = [];
                for (let c = 0; c < brickColumnCount; c++) { bricks[c] = []; for (let r = 0; r < brickRowCount; r++) { bricks[c][r] = { x: 0, y: 0, status: 1 }; } }
                if (activeGameLoop) cancelAnimationFrame(activeGameLoop);
                gameLoop();
            }
            function drawBall() { context.beginPath(); context.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); context.fillStyle = 'var(--text-primary)'; context.fill(); context.closePath(); }
            function drawPaddle() { context.beginPath(); context.rect(paddle.x, paddle.y, paddle.width, paddle.height); context.fillStyle = 'var(--primary-accent)'; context.fill(); context.closePath(); }
            function drawBricks() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        if (bricks[c][r].status === 1) {
                            let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft; let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                            bricks[c][r].x = brickX; bricks[c][r].y = brickY;
                            context.beginPath(); context.rect(brickX, brickY, brickWidth, brickHeight); context.fillStyle = 'var(--secondary-accent)'; context.fill(); context.closePath();
                        }
                    }
                }
            }
            function collisionDetection() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        let b = bricks[c][r];
                        if (b.status === 1) {
                            if (ball.x > b.x && ball.x < b.x + brickWidth && ball.y > b.y && ball.y < b.y + brickHeight) {
                                ball.dy = -ball.dy; b.status = 0; score++;
                                scoreEl.textContent = `Score: ${score}`;
                                if (score === brickRowCount * brickColumnCount) { showGameOver("VICTOIRE !", `Score final: ${score}`, initGame); return; }
                            }
                        }
                    }
                }
            }
            function gameLoop() {
                context.clearRect(0, 0, canvas.width, canvas.height);
                drawBricks(); drawBall(); drawPaddle(); collisionDetection();
                if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) ball.dx = -ball.dx;
                if (ball.y + ball.dy < ball.radius) ball.dy = -ball.dy;
                else if (ball.y + ball.dy > canvas.height - ball.radius - (paddle.height / 2)) {
                    if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) { ball.dy = -ball.dy; } 
                    else { showGameOver("GAME OVER", `Score: ${score}`, initGame); return; }
                }
                ball.x += ball.dx; ball.y += ball.dy;
                if (keys['ArrowRight'] && paddle.x < canvas.width - paddle.width) paddle.x += paddle.speed;
                if (keys['ArrowLeft'] && paddle.x > 0) paddle.x -= paddle.speed;
                activeGameLoop = requestAnimationFrame(gameLoop);
            }
            activeKeyListener = (e) => { e.preventDefault(); keys[e.key] = (e.type === 'keydown'); };
            document.addEventListener('keydown', activeKeyListener);
            document.addEventListener('keyup', activeKeyListener);
            initGame();
        }

        // --- MOTEUR DE JEU : MORPION (TicTacToe) ---
        window.initTictactoe = () => {
            const container = document.getElementById('game-tictactoe-container');
            container.innerHTML = `
                <div id="game-tictactoe">
                    <h2 class="game-title">MORPION</h2>
                    <div id="tictactoe-board"></div>
                    <div id="tictactoe-message" class="score-container"></div>
                </div>`;
            const boardEl = document.getElementById('tictactoe-board'); const messageEl = document.getElementById('tictactoe-message');
            let board, currentPlayer, gameActive;
            const winningConditions = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ];
            function initGame() {
                board = Array(9).fill(''); currentPlayer = 'X'; gameActive = true;
                messageEl.textContent = "C'est au tour de X";
                boardEl.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div'); cell.classList.add('tictactoe-cell');
                    cell.dataset.index = i; cell.addEventListener('click', handleCellClick);
                    boardEl.appendChild(cell);
                }
                activeGameLoop = null; activeKeyListener = null;
            }
            function handleCellClick(e) {
                const cell = e.target; const index = cell.dataset.index;
                if (board[index] !== '' || !gameActive || currentPlayer === 'O') return;
                makeMove(index, 'X');
                if (gameActive && !checkDraw()) { setTimeout(aiTurn, 500); }
            }
            function makeMove(index, player) {
                board[index] = player; boardEl.children[index].textContent = player; boardEl.children[index].classList.add(player);
                if (checkWin(player)) {
                    messageEl.textContent = `${player} a gagné !`; gameActive = false;
                    showGameOver(`${player} A GAGNÉ !`, "Félicitations !", initGame);
                } else if (checkDraw()) {
                    messageEl.textContent = "Égalité !"; gameActive = false;
                    showGameOver("ÉGALITÉ", "Aucun vainqueur.", initGame);
                } else {
                    currentPlayer = (player === 'X') ? 'O' : 'X';
                    messageEl.textContent = `C'est au tour de ${currentPlayer}`;
                }
            }
            function aiTurn() {
                if (!gameActive) return;
                let move = -1;
                for (let i = 0; i < board.length; i++) { if (board[i] === '') { move = i; break; } }
                if (move !== -1) { makeMove(move, 'O'); }
            }
            function checkWin(player) { return winningConditions.some(condition => condition.every(index => board[index] === player)); }
            function checkDraw() { return board.every(cell => cell !== ''); }
            initGame();
        }

        // --- MOTEUR DE JEU : FLAPPY BIRD ---
        window.initFlappybird = () => {
            const container = document.getElementById('game-flappybird-container');
            container.innerHTML = `
                <div id="game-flappybird">
                    <h2 class="game-title">FLAPPY BIRD</h2>
                    <div id="flappybird-score" class="score-container">Score: 0</div>
                    <canvas id="flappybird-board" width="288" height="512" class="game-canvas"></canvas>
                    <p class="game-instructions">Cliquez ou 'Espace' pour sauter.</p>
                </div>`;
            const canvas = document.getElementById('flappybird-board'); const context = canvas.getContext('2d');
            const scoreEl = document.getElementById('flappybird-score');
            let bird, pipes, score, gravity = 0.5, lift = -10, pipeGap = 100, pipeSpeed = 2;
            function initGame() {
                bird = { x: 50, y: 150, velocity: 0, radius: 15 }; pipes = []; score = 0;
                scoreEl.textContent = `Score: 0`;
                pipes.push({ x: canvas.width, top: 0, bottom: Math.random() * (canvas.height / 2) + 50 });
                if (activeGameLoop) cancelAnimationFrame(activeGameLoop);
                gameLoop();
            }
            function draw() {
                context.fillStyle = '#70c5ce'; context.fillRect(0, 0, canvas.width, canvas.height);
                context.beginPath(); context.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2); context.fillStyle = '#f5e356'; context.fill(); context.closePath();
                context.fillStyle = '#74bf2e';
                for (let i = 0; i < pipes.length; i++) {
                    let p = pipes[i]; let topPipeHeight = p.bottom; let bottomPipeHeight = canvas.height - (p.bottom + pipeGap);
                    context.fillRect(p.x, 0, 50, topPipeHeight);
                    context.fillRect(p.x, canvas.height - bottomPipeHeight, 50, bottomPipeHeight);
                }
            }
            function update() {
                bird.velocity += gravity; bird.velocity *= 0.9; bird.y += bird.velocity;
                for (let i = pipes.length - 1; i >= 0; i--) {
                    pipes[i].x -= pipeSpeed;
                    if (pipes[i].x + 50 < 0) { pipes.splice(i, 1); }
                    if ( bird.x + bird.radius > pipes[i].x && bird.x - bird.radius < pipes[i].x + 50 && (bird.y - bird.radius < pipes[i].bottom || bird.y + bird.radius > pipes[i].bottom + pipeGap) ) { return gameOver(); }
                    if (pipes[i].x === bird.x - 50) { score++; scoreEl.textContent = `Score: ${score}`; }
                }
                if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 150) {
                    pipes.push({ x: canvas.width, top: 0, bottom: Math.random() * (canvas.height / 3) + 100 });
                }
                if (bird.y + bird.radius > canvas.height || bird.y - bird.radius < 0) { return gameOver(); }
            }
            function gameLoop() { update(); draw(); activeGameLoop = requestAnimationFrame(gameLoop); }
            function birdJump() { bird.velocity = lift; }
            function gameOver() { cancelAnimationFrame(activeGameLoop); activeGameLoop = null; showGameOver("GAME OVER", `Score: ${score}`, initGame); }
            activeKeyListener = (e) => { if (e.key === ' ') { e.preventDefault(); birdJump(); } };
            activeMouseListener = (e) => { e.preventDefault(); birdJump(); };
            document.addEventListener('keydown', activeKeyListener);
            document.addEventListener('click', activeMouseListener);
            initGame();
        }

        // --- MOTEUR DE JEU : 2048 ---
        window.init2048 = () => {
            const container = document.getElementById('game-2048-container');
            container.innerHTML = `
                <div id="game-2048">
                    <h2 class="game-title">2048</h2>
                    <div class="score-container">Score: <span id="2048-score">0</span></div>
                    <div id="2048-board"></div>
                    <p class="game-instructions">Utilisez les flèches pour fusionner les tuiles.</p>
                </div>`;
            const boardEl = document.getElementById('2048-board'); const scoreEl = document.getElementById('2048-score');
            let grid, score;
            function initGame() {
                grid = Array(4).fill(null).map(() => Array(4).fill(0)); score = 0;
                addRandomTile(); addRandomTile();
                drawBoard();
            }
            function drawBoard() {
                scoreEl.textContent = score; boardEl.innerHTML = '';
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        const value = grid[r][c]; const tile = document.createElement('div');
                        tile.className = 'tile-2048';
                        if (value > 0) { tile.textContent = value; tile.dataset.value = value; }
                        boardEl.appendChild(tile);
                    }
                }
            }
            function addRandomTile() {
                let emptyTiles = [];
                for (let r = 0; r < 4; r++) { for (let c = 0; c < 4; c++) { if (grid[r][c] === 0) emptyTiles.push({ r, c }); } }
                if (emptyTiles.length > 0) {
                    let { r, c } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                    grid[r][c] = Math.random() < 0.9 ? 2 : 4;
                }
            }
            function slideAndMerge(row) {
                let newRow = row.filter(val => val); let missing = 4 - newRow.length; let zeros = Array(missing).fill(0);
                newRow = newRow.concat(zeros);
                for (let i = 0; i < 3; i++) {
                    if (newRow[i] > 0 && newRow[i] === newRow[i + 1]) { newRow[i] *= 2; score += newRow[i]; newRow[i + 1] = 0; }
                }
                newRow = newRow.filter(val => val); missing = 4 - newRow.length; zeros = Array(missing).fill(0);
                newRow = newRow.concat(zeros);
                return newRow;
            }
            function rotateGrid(grid) {
                let newGrid = Array(4).fill(null).map(() => Array(4).fill(0));
                for (let r = 0; r < 4; r++) { for (let c = 0; c < 4; c++) { newGrid[c][3 - r] = grid[r][c]; } }
                return newGrid;
            }
            function move(direction) {
                let moved = false;
                for (let r = 0; r < 4; r++) {
                    let row = grid[r]; let newRow = slideAndMerge(row);
                    if (JSON.stringify(row) !== JSON.stringify(newRow)) { moved = true; }
                    grid[r] = newRow;
                } return moved;
            }
            function handleMove(e) {
                e.preventDefault(); let moved = false;
                switch (e.key) {
                    case 'ArrowLeft': moved = move('left'); break;
                    case 'ArrowRight': grid = grid.map(row => row.reverse()); moved = move('right'); grid = grid.map(row => row.reverse()); break;
                    case 'ArrowUp': grid = rotateGrid(grid); moved = move('up'); grid = rotateGrid(rotateGrid(rotateGrid(grid))); break;
                    case 'ArrowDown': grid = rotateGrid(rotateGrid(rotateGrid(grid))); moved = move('down'); grid = rotateGrid(grid); break;
                }
                if (moved) { addRandomTile(); drawBoard(); checkGameOver(); }
            }
            function checkGameOver() {
                for (let r = 0; r < 4; r++) { for (let c = 0; c < 4; c++) { if (grid[r][c] === 0) return; } }
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        if (c < 3 && grid[r][c] === grid[r][c + 1]) return;
                        if (r < 3 && grid[r][c] === grid[r + 1][c]) return;
                    }
                }
                showGameOver("GAME OVER", `Score final: ${score}`, initGame);
            }
            activeKeyListener = handleMove;
            document.addEventListener('keydown', activeKeyListener);
            initGame();
        }

        // --- MOTEUR DE JEU : PUISSANCE 4 ---
        window.initConnectfour = () => {
            const container = document.getElementById('game-connectfour-container');
            container.innerHTML = `
                <div id="game-connectfour">
                    <h2 class="game-title">PUISSANCE 4</h2>
                    <div id="connectfour-board"></div>
                    <div id="connectfour-message" class="score-container"></div>
                </div>`;
            const boardEl = document.getElementById('connectfour-board'); const messageEl = document.getElementById('connectfour-message');
            const ROWS = 6, COLS = 7;
            let board, currentPlayer, gameActive;
            function initGame() {
                board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                currentPlayer = 1; gameActive = true;
                messageEl.textContent = "À vous de jouer (Rouge)";
                drawBoard();
            }
            function drawBoard() {
                boardEl.innerHTML = '';
                for (let c = 0; c < COLS; c++) {
                    const colEl = document.createElement('div'); colEl.className = 'connectfour-col'; colEl.dataset.col = c;
                    colEl.addEventListener('click', handleColumnClick);
                    for (let r = 0; r < ROWS; r++) {
                        const cell = document.createElement('div'); cell.className = 'connectfour-cell';
                        if (board[r][c] === 1) cell.classList.add('player1');
                        if (board[r][c] === 2) cell.classList.add('player2');
                        colEl.appendChild(cell);
                    }
                    boardEl.appendChild(colEl);
                }
            }
            function handleColumnClick(e) { if (!gameActive || currentPlayer === 2) return; const col = e.currentTarget.dataset.col; makeMove(parseInt(col), 1); }
            function makeMove(col, player) {
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r][col] === 0) {
                        board[r][col] = player; drawBoard();
                        if (checkWin(player)) {
                            gameActive = false; const winner = player === 1 ? "VOUS AVEZ" : "L'IA A";
                            showGameOver(`${winner} GAGNÉ !`, "Félicitations !", initGame);
                        } else if (checkDraw()) {
                            gameActive = false; showGameOver("ÉGALITÉ", "Aucun vainqueur.", initGame);
                        } else {
                            currentPlayer = player === 1 ? 2 : 1;
                            messageEl.textContent = currentPlayer === 1 ? "À vous de jouer (Rouge)" : "L'IA réfléchit... (Jaune)";
                            if (currentPlayer === 2) { setTimeout(aiTurn, 500); }
                        }
                        return;
                    }
                }
            }
            function aiTurn() {
                if (!gameActive) return;
                let availableCols = [];
                for (let c = 0; c < COLS; c++) { if (board[0][c] === 0) availableCols.push(c); }
                if (availableCols.length > 0) { const randomCol = availableCols[Math.floor(Math.random() * availableCols.length)]; makeMove(randomCol, 2); }
            }
            function checkWin(player) {
                for (let r = 0; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (board[r][c] === player && board[r][c+1] === player && board[r][c+2] === player && board[r][c+3] === player) return true; } }
                for (let c = 0; c < COLS; c++) { for (let r = 0; r <= ROWS - 4; r++) { if (board[r][c] === player && board[r+1][c] === player && board[r+2][c] === player && board[r+3][c] === player) return true; } }
                for (let r = 0; r <= ROWS - 4; r++) { for (let c = 0; c <= COLS - 4; c++) { if (board[r][c] === player && board[r+1][c+1] === player && board[r+2][c+2] === player && board[r+3][c+3] === player) return true; } }
                for (let r = 3; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (board[r][c] === player && board[r-1][c+1] === player && board[r-2][c+2] === player && board[r-3][c+3] === player) return true; } }
                return false;
            }
            function checkDraw() { return board[0].every(cell => cell !== 0); }
            initGame();
        }

        // --- MOTEUR DE JEU : PENDU ---
        window.initHangman = () => {
            const container = document.getElementById('game-hangman-container');
            container.innerHTML = `
                <div id="game-hangman">
                    <h2 class="game-title">LE PENDU</h2>
                    <div id="hangman-attempts">Tentatives restantes: 6</div>
                    <div id="hangman-word"></div>
                    <div id="hangman-keyboard"></div>
                </div>`;
            const wordEl = document.getElementById('hangman-word'); const keyboardEl = document.getElementById('hangman-keyboard');
            const attemptsEl = document.getElementById('hangman-attempts');
            const wordList = ["ARCADE", "JAVASCRIPT", "TETRIS", "SNAKE", "PONG", "DEVELOPPEUR", "ORDINATEUR", "PROGRAMME", "NAVIGATEUR"];
            let selectedWord, guessedLetters, wrongAttempts;
            function initGame() {
                selectedWord = wordList[Math.floor(Math.random() * wordList.length)];
                guessedLetters = Array(selectedWord.length).fill('_'); wrongAttempts = 6;
                drawWord(); drawKeyboard(); updateAttempts();
            }
            function drawWord() {
                wordEl.innerHTML = '';
                guessedLetters.forEach(letter => {
                    const letterEl = document.createElement('div'); letterEl.className = 'hangman-letter';
                    letterEl.textContent = letter === '_' ? '' : letter;
                    wordEl.appendChild(letterEl);
                });
            }
            function drawKeyboard() {
                keyboardEl.innerHTML = '';
                for (let i = 65; i <= 90; i++) {
                    const letter = String.fromCharCode(i); const key = document.createElement('button');
                    key.className = 'hangman-key'; key.textContent = letter;
                    key.addEventListener('click', () => handleGuess(letter));
                    keyboardEl.appendChild(key);
                }
            }
            function handleGuess(letter) {
                const key = Array.from(keyboardEl.children).find(k => k.textContent === letter);
                if (key.disabled) return;
                key.disabled = true;
                if (selectedWord.includes(letter)) {
                    for (let i = 0; i < selectedWord.length; i++) { if (selectedWord[i] === letter) { guessedLetters[i] = letter; } }
                } else { wrongAttempts--; updateAttempts(); }
                drawWord(); checkGameState();
            }
            function updateAttempts() { attemptsEl.textContent = `Tentatives restantes: ${wrongAttempts}`; }
            function checkGameState() {
                if (guessedLetters.join('') === selectedWord) { showGameOver("VICTOIRE !", `Le mot était: ${selectedWord}`, initGame); } 
                else if (wrongAttempts <= 0) { showGameOver("GAME OVER", `Le mot était: ${selectedWord}`, initGame); }
            }
            initGame();
        }

        // --- MOTEUR DE JEU : MEMORY ---
        window.initMemory = () => {
            const container = document.getElementById('game-memory-container');
            container.innerHTML = `
                <div id="game-memory">
                    <h2 class="game-title">MEMORY</h2>
                    <div id="memory-moves" class="score-container">Coups: 0</div>
                    <div id="memory-grid"></div>
                </div>`;
            const gridEl = document.getElementById('memory-grid'); const movesEl = document.getElementById('memory-moves');
            const icons = [ "bi-bug-fill", "bi-joystick", "bi-bricks", "bi-suit-club-fill", "bi-cloud-fill", "bi-flag-fill", "bi-hash", "bi-suit-spade-fill" ];
            let cards, flippedCards, matchedPairs, moves, gameActive;
            function initGame() {
                let cardSet = [...icons, ...icons];
                cards = cardSet.sort(() => 0.5 - Math.random());
                flippedCards = []; matchedPairs = 0; moves = 0; gameActive = true;
                movesEl.textContent = "Coups: 0";
                drawGrid();
            }
            function drawGrid() {
                gridEl.innerHTML = '';
                cards.forEach((icon, index) => {
                    const card = document.createElement('div'); card.className = 'memory-card';
                    card.dataset.index = index; card.dataset.icon = icon;
                    card.innerHTML = `
                        <div class="card-face card-front"></div>
                        <div class="card-face card-back"><i class="bi ${icon}"></i></div>
                    `;
                    card.addEventListener('click', handleCardClick);
                    gridEl.appendChild(card);
                });
            }
            function handleCardClick(e) {
                const card = e.currentTarget;
                if (!gameActive || card.classList.contains('is-flipped') || card.classList.contains('is-matched')) return;
                card.classList.add('is-flipped');
                flippedCards.push(card);
                if (flippedCards.length === 2) {
                    gameActive = false; moves++;
                    movesEl.textContent = `Coups: ${moves}`;
                    setTimeout(checkForMatch, 1000);
                }
            }
            function checkForMatch() {
                const [card1, card2] = flippedCards;
                if (card1.dataset.icon === card2.dataset.icon) {
                    card1.classList.add('is-matched'); card2.classList.add('is-matched');
                    matchedPairs++;
                    if (matchedPairs === icons.length) { showGameOver("VICTOIRE !", `Terminé en ${moves} coups !`, initGame); }
                } else {
                    card1.classList.remove('is-flipped'); card2.classList.remove('is-flipped');
                }
                flippedCards = []; gameActive = true;
            }
            initGame();
        }

        // --- NOUVEAU JEU : DÉMINEUR ---
        window.initMinesweeper = () => {
            const container = document.getElementById('game-minesweeper-container');
            const ROWS = 10, COLS = 10, MINES = 15;
            container.innerHTML = `
                <div id="game-minesweeper">
                    <h2 class="game-title">DÉMINEUR</h2>
                    <div id="minesweeper-info">Mines restantes: <span id="minesweeper-mines">${MINES}</span></div>
                    <div id="minesweeper-board"></div>
                    <p class="game-instructions">Clic gauche: Révéler | Clic droit: Marquer</p>
                </div>`;
            
            const boardEl = document.getElementById('minesweeper-board');
            const minesEl = document.getElementById('minesweeper-mines');
            let board, gameActive, mineCount;

            function initGame() {
                board = Array(ROWS).fill(null).map(() => Array(COLS).fill(null).map(() => ({
                    isMine: false, isRevealed: false, isFlagged: false, neighborCount: 0
                })));
                gameActive = true;
                mineCount = MINES;
                minesEl.textContent = mineCount;
                
                // Placer les mines
                let minesPlaced = 0;
                while (minesPlaced < MINES) {
                    let r = Math.floor(Math.random() * ROWS);
                    let c = Math.floor(Math.random() * COLS);
                    if (!board[r][c].isMine) {
                        board[r][c].isMine = true;
                        minesPlaced++;
                    }
                }
                
                // Compter les voisins
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c].isMine) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc].isMine) {
                                    count++;
                                }
                            }
                        }
                        board[r][c].neighborCount = count;
                    }
                }
                
                drawBoard();
            }

            function drawBoard() {
                boardEl.innerHTML = '';
                boardEl.style.gridTemplateColumns = `repeat(${COLS}, 30px)`;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'minesweeper-cell';
                        cell.dataset.r = r; cell.dataset.c = c;
                        
                        const cellData = board[r][c];
                        if (cellData.isRevealed) {
                            cell.classList.add('revealed');
                            if (cellData.isMine) {
                                cell.classList.add('mine');
                                cell.innerHTML = '<i class="bi bi-person-fill-exclamation"></i>';
                            } else if (cellData.neighborCount > 0) {
                                cell.textContent = cellData.neighborCount;
                                cell.dataset.count = cellData.neighborCount;
                            }
                        } else if (cellData.isFlagged) {
                            cell.classList.add('flagged');
                            cell.innerHTML = '<i class="bi bi-flag-fill"></i>';
                        }
                        
                        cell.addEventListener('click', () => handleCellClick(r, c));
                        cell.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            handleCellRightClick(r, c);
                        });
                        boardEl.appendChild(cell);
                    }
                }
            }

            function handleCellClick(r, c) {
                if (!gameActive || board[r][c].isRevealed || board[r][c].isFlagged) return;
                
                if (board[r][c].isMine) {
                    gameOver(false);
                    return;
                }
                
                revealCell(r, c);
                checkWin();
            }

            function handleCellRightClick(r, c) {
                if (!gameActive || board[r][c].isRevealed) return;
                
                board[r][c].isFlagged = !board[r][c].isFlagged;
                mineCount += board[r][c].isFlagged ? -1 : 1;
                minesEl.textContent = mineCount;
                drawBoard();
            }

            function revealCell(r, c) {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS || board[r][c].isRevealed || board[r][c].isFlagged) return;
                
                board[r][c].isRevealed = true;
                
                if (board[r][c].neighborCount === 0 && !board[r][c].isMine) {
                    // Flood fill
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            revealCell(r + dr, c + dc);
                        }
                    }
                }
            }

            function gameOver(isWin) {
                gameActive = false;
                // Révéler toutes les mines
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c].isMine) board[r][c].isRevealed = true;
                    }
                }
                drawBoard();
                if (isWin) {
                    showGameOver("VICTOIRE !", "Vous avez trouvé toutes les mines !", initGame);
                } else {
                    showGameOver("GAME OVER", "Vous avez cliqué sur une mine...", initGame);
                }
            }

            function checkWin() {
                let revealedCount = 0;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c].isRevealed) revealedCount++;
                    }
                }
                if (revealedCount === ROWS * COLS - MINES) {
                    gameOver(true);
                }
            }
            
            // Attacher les listeners de souris au document pour les enlever dans cleanUp()
            activeMouseListener = (e) => {
                const cell = e.target.closest('.minesweeper-cell');
                if (cell) {
                    const r = parseInt(cell.dataset.r);
                    const c = parseInt(cell.dataset.c);
                    if (e.type === 'click') {
                        handleCellClick(r, c);
                    } else if (e.type === 'contextmenu') {
                        e.preventDefault();
                        handleCellRightClick(r, c);
                    }
                }
            };
            
            // Démineur n'utilise pas le listener global, il attache les siens
            // mais on doit s'assurer que cleanUp() fonctionne
            // Mieux: utiliser le listener global
            document.addEventListener('click', activeMouseListener);
            document.addEventListener('contextmenu', activeMouseListener);
            
            initGame();
        }

        // --- NOUVEAU JEU : BLACKJACK ---
        window.initBlackjack = () => {
            const container = document.getElementById('game-blackjack-container');
            container.innerHTML = `
                <div id="game-blackjack">
                    <h2 class="game-title">BLACKJACK</h2>
                    
                    <div id="blackjack-dealer-hand-container">
                        <h4 id="blackjack-dealer-score" class="score-container" style="font-family: var(--font-pixel); font-size: 1rem;">Main du Croupier: ?</h4>
                        <div id="blackjack-dealer-hand" class="blackjack-hand"></div>
                    </div>
                    
                    <div id="blackjack-player-hand-container">
                        <h4 id="blackjack-player-score" class="score-container" style="font-family: var(--font-pixel); font-size: 1rem;">Votre Main: 0</h4>
                        <div id="blackjack-player-hand" class="blackjack-hand"></div>
                    </div>

                    <div id="blackjack-controls">
                        <button id="blackjack-hit-btn" class="game-btn">Tirer (Hit)</button>
                        <button id="blackjack-stand-btn" class="game-btn">Rester (Stand)</button>
                    </div>
                    
                    <div id="blackjack-message" class="score-container"></div>
                </div>`;
            
            const playerHandEl = document.getElementById('blackjack-player-hand');
            const dealerHandEl = document.getElementById('blackjack-dealer-hand');
            const playerScoreEl = document.getElementById('blackjack-player-score');
            const dealerScoreEl = document.getElementById('blackjack-dealer-score');
            const messageEl = document.getElementById('blackjack-message');
            const hitBtn = document.getElementById('blackjack-hit-btn');
            const standBtn = document.getElementById('blackjack-stand-btn');

            let deck, playerHand, dealerHand, gameActive;
            const SUITS = ['♥', '♦', '♣', '♠'];
            const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];

            function initGame() {
                deck = createDeck();
                playerHand = [drawCard(), drawCard()];
                dealerHand = [drawCard(), drawCard()];
                gameActive = true;
                messageEl.textContent = "Tirer ou Rester ?";
                toggleButtons(true);
                drawHands();
            }

            function createDeck() {
                let newDeck = [];
                for (let suit of SUITS) {
                    for (let rank of RANKS) {
                        newDeck.push({ suit, rank });
                    }
                }
                return newDeck.sort(() => Math.random() - 0.5);
            }

            function drawCard() {
                if (deck.length === 0) deck = createDeck();
                return deck.pop();
            }

            function drawHands() {
                playerHandEl.innerHTML = '';
                playerHand.forEach(card => playerHandEl.appendChild(createCardEl(card)));
                playerScoreEl.textContent = `Votre Main: ${getHandScore(playerHand)}`;

                dealerHandEl.innerHTML = '';
                dealerHandEl.appendChild(createCardEl(dealerHand[0]));
                dealerHandEl.appendChild(createCardEl(dealerHand[1], !gameActive));
                dealerScoreEl.textContent = `Main du Croupier: ${gameActive ? getCardValue(dealerHand[0]) + ' + ?' : getHandScore(dealerHand)}`;
            }

            function createCardEl(card, isHidden = false) {
                const cardEl = document.createElement('div');
                if (isHidden) {
                    cardEl.className = 'blackjack-card blackjack-card-hidden';
                    return cardEl;
                }
                cardEl.className = `blackjack-card ${card.suit === '♥' || card.suit === '♦' ? 'red' : ''}`;
                cardEl.innerHTML = `<span class="blackjack-card-value">${card.rank}</span><span class="blackjack-card-suit">${card.suit}</span>`;
                return cardEl;
            }

            function getCardValue(card) {
                if (['T', 'J', 'Q', 'K'].includes(card.rank)) return 10;
                if (card.rank === 'A') return 11;
                return parseInt(card.rank);
            }

            function getHandScore(hand) {
                let score = 0;
                let aceCount = 0;
                for (let card of hand) {
                    score += getCardValue(card);
                    if (card.rank === 'A') aceCount++;
                }
                while (score > 21 && aceCount > 0) {
                    score -= 10;
                    aceCount--;
                }
                return score;
            }

            function handleHit() {
                if (!gameActive) return;
                playerHand.push(drawCard());
                drawHands();
                const score = getHandScore(playerHand);
                if (score > 21) {
                    endGame("Vous avez dépassé 21 ! C'est perdu.", false);
                }
            }

            function handleStand() {
                if (!gameActive) return;
                gameActive = false;
                toggleButtons(false);
                dealerTurn();
            }

            function dealerTurn() {
                drawHands();
                let dealerScore = getHandScore(dealerHand);
                
                if (dealerScore > 21) {
                    endGame("Le croupier dépasse 21 ! Vous gagnez.", true);
                } else if (dealerScore >= 17) {
                    // Le croupier s'arrête
                    const playerScore = getHandScore(playerHand);
                    if (playerScore > dealerScore) {
                        endGame("Vous gagnez !", true);
                    } else if (playerScore < dealerScore) {
                        endGame("Le croupier gagne.", false);
                    } else {
                        endGame("Égalité !", null);
                    }
                } else {
                    // Le croupier tire
                    dealerHand.push(drawCard());
                    setTimeout(dealerTurn, 1000);
                }
            }

            function toggleButtons(enabled) {
                hitBtn.disabled = !enabled;
                standBtn.disabled = !enabled;
            }

            function endGame(msg, playerWon) {
                gameActive = false;
                toggleButtons(false);
                messageEl.textContent = msg;
                drawHands(); // Révèle la carte cachée
                
                let title = playerWon ? "VICTOIRE !" : (playerWon === false ? "GAME OVER" : "ÉGALITÉ");
                showGameOver(title, msg, initGame);
            }

            hitBtn.addEventListener('click', handleHit);
            standBtn.addEventListener('click', handleStand);

            initGame();
        }


        // --- MOTEURS DE JEU : PROCHAINEMENT... ---
        function createComingSoon(gameName, iconClass) {
            return () => {
                const container = document.getElementById(`game-${gameName.toLowerCase().replace(/[\s-]/g, '')}-container`);
                container.innerHTML = `
                    <div class="coming-soon">
                        <i class="${iconClass}" style="font-size: 5rem; color: var(--primary-accent);"></i>
                        <h2 class="game-title" style="margin-top: 2rem;">${gameName}</h2>
                        <p>Prochainement...</p>
                    </div>`;
                activeGameLoop = null;
                activeKeyListener = null;
            }
        }

        window.initPacman = createComingSoon('Pac-Man', 'bi bi-joystick');

    });
    </script>
</body>
</html>
